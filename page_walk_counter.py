#!/usr/bin/env python3

'''
This script evaulates the log file generated by the perf script.
It is useful when evaulating the PW latency statistics.

Usage:
File generated by perf script
Partitons, separated by comma, unit: runs
Inclusions, separated by comma, unit: run# (starting from #1, cannot co-exist with exclusions)
Exclusions, separated by comma, unit: run# (starting from #1, cannot co-exist with inclusions)
Deletions, separated by comma, unit: run# (starting from #1)
Clear flag
Output file (not required, default to input file; ignored if not modifying)
Verbose flag

Example:
chmod +x page_walk_counter.py
./page_walk_counter.py perf-always.log -p 3,3 -e 1 (Partitons: run 2,3,4; run 5,6,7; 1 excluded)
'''

import sys
import os
import statistics

'''
Print usage and exit abnormally. (Why python does not support goto?)

Args:
Arguments.

Returns:
-1 to the OS.
'''
def print_usage_and_exit(args):
    print("Usage:", args[0], "perf.log", "[-p partitions]", "[-i inclusions | -e exclusions]", "[-d deletions]", "[-c]", "[-o output.log]", "[-v]")
    sys.exit(-1)

'''
Parse the argument from argument list with supported switch into list of runs.

Args:
Switch of the argument, error message, and argument list.

Returns:
List of runs supplied after the switch as integers.
'''
def parse_runs(switch, message, args):
    ret = []
    if switch in args:
        try:
            arg = "(None)"
            arg = args.pop(args.index(switch) + 1)
            ret = [int(i) for i in arg.split(",")]
            args.remove(switch)
        except:
            print(message, arg)
            print_usage_and_exit(args)
    return ret

# Parse/get arguments
args = sys.argv.copy()
if len(args) < 2:
    print_usage_and_exit(args)

partition = parse_runs("-p", "Invalid partition argument:", args)
inclusion = parse_runs("-i", "Invalid inclusion argument:", args)
exclusion = parse_runs("-e", "Invalid exclusion argument:", args)
deletion = parse_runs("-d", "Invalid deletion argument:", args)
out = None
if "-o" in args:
    try:
        out = args.pop(args.index("-o") + 1)
        args.remove("-o")
    except:
        print("Invalid output file")
        print_usage_and_exit(args)

clear = False
if "-c" in args:
    clear = True
    args.remove("-c")

verbose = False
if "-v" in args:
    verbose = True
    args.remove("-v")

try:
    arg = args.pop(1)
except:
    print("Cannot parse log file path")
    print_usage_and_exit(args)
if not os.path.isfile(arg):
    print("Cannot access log file:", arg)
    print_usage_and_exit(args)
if not os.path.getsize(arg):
    print("Log file is empty:", arg)
    print_usage_and_exit(args)

if len(args) > 1:
    print("Unrecognized argument(s):", args[1 :])
    print_usage_and_exit(args)

# Further checking and file loading
if inclusion and exclusion:
    print("Inclusion and exclusion cannot exist at the same time")
    print_usage_and_exit(args)

file = []
try:
    with open(arg) as infile:
        print("Loading...")
        for line in infile:
            file.append(line)
except:
    print("Error opening file:", arg)
    print_usage_and_exit(args)

if not out:
    out = arg

valid_cols = ["dtlb_load_misses.walk_completed", "dtlb_load_misses.walk_pending", "dtlb_load_misses.walk_active",
              "dtlb_store_misses.walk_completed", "dtlb_store_misses.walk_pending", "dtlb_store_misses.walk_active",
              "itlb_misses.walk_completed", "itlb_misses.walk_pending", "itlb_misses.walk_active",
              "cycles:ukhHG"]

'''
Read a line in the perf file.

Args:
A line in the perf file.

Returns:
If the line contains valid data, return the 3 columns of interest plus CPU speed if available (len = 4)
If the line contains benchmark result, return the result (len = 1)
If the line is invalid, return an empty list (len = 0)
'''
def read_line(line):
    time = 0.0
    counts = 0
    col = 0
    speed = 0.0
    components = line.split(" ")
    if components[0] == "Took:":
        return [float(components[1].split("\n")[0])]
    if "GHz" in components:
        speed = float(components[components.index("GHz") - 1])
    for component in components:
        if component == "":
            continue
        try:
            if col == 0:
                time = float(component)
                col += 1
            elif col == 1:
                component = component.replace(",", "")
                counts = int(component)
                col += 1
            elif col == 2:
                if component in valid_cols:
                    return [time, counts, component, speed]
                else:
                    return []
        except:
            return []
    return []

'''
Calculate the page walk latency and TLB misses.

Args:
Counts of columns of interest from one run.

Returns:
Page walk latency and TLB misses.
'''
def get_pw_latency(event_counts):
    pending = event_counts[valid_cols.index("dtlb_load_misses.walk_pending")] +\
        event_counts[valid_cols.index("dtlb_store_misses.walk_pending")] +\
        event_counts[valid_cols.index("itlb_misses.walk_pending")]
    completed = event_counts[valid_cols.index("dtlb_load_misses.walk_completed")] +\
        event_counts[valid_cols.index("dtlb_store_misses.walk_completed")] +\
        event_counts[valid_cols.index("itlb_misses.walk_completed")]
    if not completed:
        print("Warning: divide by zero when calculating PW latency")
        return 0.0
    return pending / completed, completed

'''
Get relative precentage with all available data.

Args:
Current data and all available data as numbers in a list.

Returns:
Relative precentages formatted as strings in a list.
'''
def get_relative(current, all):
    ret = []
    for i in all:
        ret += ['{:.3%}'.format((i - current) / current)]
    return ret

'''
Read one run in the perf file.

Args:
A line number in the perf file.

Returns:
A list contains the next line, runtime, PW latency, speed, eval time, from to last lines, and columns of interest, accumulated.
If the run is the last run, the line number will be 0.
If the run is not the last run, the line number will be the begining of the next run.
'''
def read_run(line_num):
    end_time = 0.0
    end_linenum = 0
    next_linenum = 0
    runtime = 0.0
    pw_latency = 0.0
    tlb_miss = 0
    speed = 0.0
    speed_count = 0
    avg_speed = 0.0
    event_counts = [0] * len(valid_cols)
    for i in range(line_num, len(file)):
        cols = read_line(file[i])
        if len(cols) == 4:
            if cols[0] >= end_time:
                end_time = cols[0]
                event_counts[valid_cols.index(cols[2])] += cols[1]
                if cols[3]:
                    speed += cols[3]
                    speed_count += 1
            elif cols[0] < end_time:
                next_linenum = end_linenum
                end_linenum -= 1
                break
        elif len(cols) == 1:
            if runtime != 0 and cols[0] != runtime:
                print("Warning: runtime differs in one run")
            runtime = cols[0]
        end_linenum = i
    pw_latency, tlb_miss = get_pw_latency(event_counts)
    if not speed_count:
        print("Warning: divide by zero when calculating the average CPU speed")
    else:
        avg_speed = speed / speed_count
    return [next_linenum, runtime, pw_latency, tlb_miss, avg_speed, end_time, line_num, end_linenum] + event_counts

'''
Print the ending notes.

Args:
Deleted runs, omitted runs, saved file, and clear flag.

Returns:
0 to the OS.
'''
def print_ending(deleted, omitted, savefile, clear):
    if deleted or omitted or savefile or clear:
        print("")
    if clear and omitted:
        print("Note: found", len(omitted), "incomplete runs and cleared them:", omitted)
    elif omitted:
        print("Note: found", len(omitted), "incomplete runs and omitted them:", omitted)
    elif clear:
        print("Note: did not found any incomplete runs")
    if deleted:
        print("Note: deleted", len(deleted), "runs:", deleted)
    if savefile:
        print("Note: new log file saved as", savefile)
    exit(0)

# Evaluate all runs, record and print summaries, delete if necessary.
line_num = 0
eval_count = 0
run_num = []
runtime = []
pw_latency = []
tlb_miss = []
speed = []
stats = []
del_lines = []
omitted = []
deleted = []
while True:
    this_stats = read_run(line_num)
    line_num, this_runtime, this_latency, this_miss, this_speed = this_stats[0 : 5]
    eval_count += 1
    if not this_runtime:
        omitted += [eval_count]
        if clear:
            del_lines += list(range(this_stats[6], this_stats[7] + 1))
    if eval_count in deletion:
        deleted += [eval_count]
        del_lines += list(range(this_stats[6], this_stats[7] + 1))
    if eval_count not in deletion and this_runtime:
        if (eval_count in inclusion) or (not inclusion and eval_count not in exclusion):
            runtime += [this_runtime]
            pw_latency += [this_latency]
            tlb_miss += [this_miss]
            speed += [this_speed]
            stats += [this_stats[5 :]]
            run_num += [eval_count]
    if not line_num:
        break

savefile = None
if del_lines or arg != out:
    try:
        with open(out, "w") as outfile:
            for i in range(0, len(file)):
                if i not in del_lines:
                    outfile.write(file[i])
        savefile = out
    except:
        print("Error writing file:", out)
        exit(-1)

if not run_num:
    print("Warning: did not successfully read any run")
    print_ending(deleted, omitted, savefile, clear)

for i in range(0, len(run_num)):
    print("")
    print("Run #", run_num[i], ", duration: ", stats[i][0], ", lines: ", stats[i][1] + 1, " -> ", stats[i][2] + 1, sep="")
    print("Runtime:", '{:.3f}'.format(runtime[i]))
    print("Relative runtime:", get_relative(runtime[i], runtime))
    print("Page walk latency:", '{:.3f}'.format(pw_latency[i]))
    print("Relative latency:", get_relative(pw_latency[i], pw_latency))
    print("Total TLB misses:", '{:.3f}'.format(tlb_miss[i]))
    print("Relative TLB misses:", get_relative(tlb_miss[i], tlb_miss))
    print("Reference CPU speed:", '{:.3f}'.format(speed[i]), "GHz")
    print("Relative CPU speed:", get_relative(speed[i], speed))
    if verbose:
        for j in range(3, len(stats[i])):
            print(valid_cols[j - 3], stats[i][j], sep=": ")

# Evaulate all partitions if supplied, print summaries.
partition_sum = sum(partition)
run_start = 0
run_end = 0
avg_runtime = []
avg_latency = []
avg_miss = []
avg_speed = []
if not len(partition) or partition_sum > len(run_num):
    print("")
    print("Overall summary:")
    print("Average runtime:", '{:.3f}'.format(statistics.mean(runtime)))
    print("Average page walk latency:", '{:.3f}'.format(statistics.mean(pw_latency)))
    print("Average TLB misses", '{:.3f}'.format(statistics.mean(tlb_miss)))
    print("Average CPU speed:", '{:.3f}'.format(statistics.mean(speed)), "GHz")
    if len(partition):
        print("Warning: paritions are not applied because there are not enough runs to evaulate")
    print_ending(deleted, omitted, savefile, clear)
else:
    for i in range(0, len(partition)):
        run_end = run_start + partition[i]
        avg_runtime += [statistics.mean(runtime[run_start : run_end])]
        avg_latency += [statistics.mean(pw_latency[run_start : run_end])]
        avg_miss += [statistics.mean(tlb_miss[run_start : run_end])]
        avg_speed += [statistics.mean(speed[run_start : run_end])]
        run_start = run_end

run_start = 0
run_end = 0
for i in range(0, len(partition)):
    run_end = run_start + partition[i]
    print("")
    print("Partition #", i + 1, " summary, runs: ", run_num[run_start : run_end], sep="")
    print("Average runtime:", '{:.3f}'.format(avg_runtime[i]))
    print("Relative average runtime:", get_relative(avg_runtime[i], avg_runtime))
    print("Average page walk latency:", '{:.3f}'.format(avg_latency[i]))
    print("Relative page walk latency:", get_relative(avg_latency[i], avg_latency))
    print("Average TLB misses", '{:.3f}'.format(avg_miss[i]))
    print("Relative page walk latency:", get_relative(avg_miss[i], avg_miss))
    print("Average CPU speed:", '{:.3f}'.format(avg_speed[i]), "GHz")
    print("Relative CPU speed:", get_relative(avg_speed[i], avg_speed))
    run_start = run_end
print_ending(deleted, omitted, savefile, clear)
